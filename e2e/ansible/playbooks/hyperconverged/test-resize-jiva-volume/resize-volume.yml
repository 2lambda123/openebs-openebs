# STEPS INVOLUVED:
#1) Deploy OpenEBS
#2) Deploy percona
#3) Fill data
#4) Get the node where application is running
#5) Unmount the file system
#6) Logout the iscsi target
#7) Get the id of the volume
#8) Modfiy the volume size
#9) Restart the replicas
#10) Expanc the file system
#)11) Mount the file system


- hosts: localhost

  vars_files:
    - resize-volume-vars.yml

  tasks:

    - block:
    
        - name: Check whether maya-apiserver pod is running
          shell: source ~/.profile; kubectl get pods --all-namespaces | grep maya-apiserver
          args:
            executable: /bin/bash
          register: result
          delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
          until: "'Running' in result.stdout"
          delay: 30
          retries: 5

        - name: Get $HOME of K8s master for kubernetes user
          shell: source ~/.profile; echo $HOME
          args:
            executable: /bin/bash
          register: result_kube_home
          delegate_to: "{{groups['kubernetes-kubemasters'].0}}" 
 
        - name: Copy the percona definition yaml to k8s master
          copy:
            src: "{{ percona_def }}"
            dest: "{{ result_kube_home.stdout }}"
          delegate_to: "{{ groups['kubernetes-kubemasters'].0 }}"

        - name: Getting the node name
          shell: kubectl get nodes -o wide  | awk {'print $1'} | awk 'FNR == 4{print}'
          args:
            executable: /bin/bash
          register: node_name
          delegate_to: "{{ groups['kubernetes-kubemasters'].0 }}"
  
        - name: Creating label for the node
          shell: kubectl label nodes {{node_name.stdout}} app=percona
          args:
            executable: /bin/bash
          register: label
          delegate_to: "{{ groups['kubernetes-kubemasters'].0 }}"
          until: '"labeled" in label.stdout'
          delay: 10
          retries: 3

        - name: Deploying application
          shell: source ~/.profile; kubectl apply -f "{{ percona_def }}"
          args:
            executable: /bin/bash
          register: percona_status
          delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
          until: "'deployment \"percona\" created' in percona_status.stdout"
          delay: 30
          retries: 5
        
        - name: Checking if the application is deployed successfully
          shell: kubectl get pods --all-namespaces | grep percona
          args:
            executable: /bin/bash
          register: app_status
          delegate_to: "{{ groups['kubernetes-kubemasters'].0 }}"
          until: "'Running' in app_status.stdout"
          delay: 30
          retries: 15
    
        - name: Getting PV name
          shell: kubectl get pv | grep openebs-percona | awk {'print $1'}
          args:
            executable: /bin/bash
          register: pv
          delegate_to: "{{ groups['kubernetes-kubemasters'].0 }}"
         
        - name: Getting the controller service IP address
          shell: kubectl get svc | grep "{{ pv.stdout }}" | grep ctrl | awk {'print $3'}
          args:
            executable: /bin/bash
          register: target_IP
          delegate_to: "{{ groups['kubernetes-kubemasters'].0}}"
         
        - name: Getting the device name
          shell: fdisk -l | grep "5 G" | awk {'print $2'} | sed 's/.$//'
          args: 
            executable: /bin/bash
          become: true
          register: device_name
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"
 
        - name: Getting the mounted directory
          shell: mount | grep "{{ device_name.stdout }}" | awk {'print $3'} | awk 'FNR == 1 {print}'
          args:
            executable: /bin/bash
          register: mount_path
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"

        - name: Unmount the file system
          mount:
            name: "{{ mount_path.stdout }}"
            state: unmounted
          become: true
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"
         # shell: umount -l "{{ mount_path.stdout }}"
         # args:
         #   executable: /bin/bash
         # become: true
         # register: unmount
         # delegate_to: "{{groups['kubernetes-kubeminions'].1}}"


        - name: Finding the iSCSI target name
          shell: iscsiadm -m session | grep "{{ target_IP.stdout}}"| awk {'print $4'}
          args:
            executable: /bin/bash
          become: true
          register: iqn
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"
          

        - name: Logging out the iSCSI target 
          open_iscsi:
            login: no
            target: "{{ iqn.stdout }}"
          #shell: iscsiadm -m node -T "{{ iqn.stdout }}" -u
          #args: 
          #  executable: /bin/bash
          become: true
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"

        - name: Getting the response of volume api
          shell: curl http://"{{target_IP.stdout}}":9501/v1/volumes
          args:
            executable: /bin/bash
          register: resp
          delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
          
        - set_fact:
            vol_id: "{{ (resp.stdout | from_json).data[0].id  }}"
        
        - name: Modify the capacity of volume
          uri:
            url: http://{{target_IP.stdout}}:9501/v1/volumes/{{vol_id}}?action=resize
            method: POST
            return_content: yes
            body: {"name":"{{pv.stdout}}","size":"6 G"}
            body_format: json
            headers:
              Content-Type: "application/json"
          register: modify
          delegate_to: "{{ groups['kubernetes-kubemasters'].0}}"
         
        - name: Get the list of pods
          shell: kubectl get pods | grep {{ pv.stdout }} | grep rep | awk {'print $1'} | awk 'FNR == 1 {print}'
          args:
            executable: /bin/bash
          register: rep1
          delegate_to: "{{ groups['kubernetes-kubemasters'].0}}"

        - name: Get the list of pods
          shell: kubectl get pods | grep {{ pv.stdout }} | grep rep | awk {'print $1'} | awk 'FNR == 2 {print}'
          args:
            executable: /bin/bash
          register: rep2
          delegate_to: "{{ groups['kubernetes-kubemasters'].0}}"

        - name: Get the list of pods
          shell: kubectl get pods | grep {{ pv.stdout }} | grep rep | awk {'print $1'} | awk 'FNR == 3 {print}'
          args:
            executable: /bin/bash
          register: rep3
          delegate_to: "{{ groups['kubernetes-kubemasters'].0}}"

        - name: Kill pods
          shell: kubectl delete pod {{rep1.stdout}} {{rep2.stdout}} {{rep3.stdout}}
          args:
            executable: /bin/bash
          delegate_to: "{{ groups['kubernetes-kubemasters'].0}}"
 
        - name: Login to iSCSI target
          open_iscsi:
            show_nodes: yes
            login: yes
            target: "{{ iqn.stdout }}"
          become: yes
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"
      
        - name: Finding the new device name
          shell: fdisk -l | grep "6 G" | awk {'print $2'} | sed 's/.$//'
          args:
            executable: /bin/bash
          become: true
          register: new_device
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"
 
        - name: Running fsck on the new device
          shell: e2fsck -f {{ new_device.stdout }} -y
          args:
            executable: /bin/bash
          become: true
          register: fs_check
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"
          until: '"MODIFIED" or "clean" in fs_check.stdout'
          delay: 20
          retries: 5
          ignore_errors: yes

        - name: Resizing the file system
          shell: resize2fs {{ new_device.stdout }}
          args:
            executable: /bin/bash
          become: true
          register: resize
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"
          until: "'Resizing the filesystem on' in resize.stdout"
          delay: 20
          retries: 10
 
        - name: Getting application pod
          shell: kubectl get pods --all-namespaces | grep percona | awk {'print$2'}
          args:
            executable: /bin/bash
          register: app
          delegate_to: "{{ groups['kubernetes-kubemasters'].0}}"
          
        - name: Deleting the application pod
          shell: kubectl delete pod {{ app.stdout }}
          args:
            executable: /bin/bash
          register: delete_app
          delegate_to: "{{ groups['kubernetes-kubemasters'].0}}"
          until: "'deleted' in delete_app.stdout"
          delay: 10
          retries: 5
  
        - name: Mounting the file system
          mount:
            path: "{{ mount_path.stdout }}"
            src: "{{ new_device.stdout }}"
            fstype: ext4
            state: mounted
          delegate_to: "{{groups['kubernetes-kubeminions'].1}}"

        - set_fact:       
            flag: "PASS"
 
      rescue:
        - set_fact:
            flag: "FAIL"

      always:

        - include: resize-cleanup.yml
          when: clean | bool

        - name: Send slack notification
          slack:
            token: "{{ lookup('env','SLACK_TOKEN') }}"
            msg: '{{ ansible_date_time.time }} TEST: {{test_name}}, RESULT: {{ flag }}'
          when: slack_notify | bool and lookup('env','SLACK_TOKEN')

            
        

        
       
